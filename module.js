define(["@grafana/data","rxjs","@grafana/runtime","react","@grafana/ui","lodash"],((e,t,n,a,r,o)=>(()=>{"use strict";var i={305:t=>{t.exports=e},545:e=>{e.exports=n},388:e=>{e.exports=r},980:e=>{e.exports=o},650:e=>{e.exports=a},177:e=>{e.exports=t}},l={};function s(e){var t=l[e];if(void 0!==t)return t.exports;var n=l[e]={exports:{}};return i[e](n,n.exports,s),n.exports}s.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return s.d(t,{a:t}),t},s.d=(e,t)=>{for(var n in t)s.o(t,n)&&!s.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},s.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),s.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var c={};return(()=>{s.r(c),s.d(c,{plugin:()=>D});var e,t=s(305),n=s(177),a=s(545);!function(e){e.Timeseries="Timeseries",e.Table="Table"}(e||(e={}));const r={database:"my_db",collection:"my_collection",queryType:e.Timeseries,timestampField:"timestamp",timestampFormat:"",labelFields:["sensorID"],legendFormat:"",valueFields:["measurement"],valueFieldTypes:["float64"],aggregation:JSON.stringify([{$project:{timestamp:1,sensorID:"$metadata.sensorID",measurement:1,_id:0}}]),autoTimeBound:!1,autoTimeSort:!1,schemaInference:!1,schemaInferenceDepth:20},o={database:"my_db",collection:"my_collection",aggregation:JSON.stringify([{$group:{_id:"$label",count:{$sum:1}}}]),fieldName:"_id",fieldType:"string"};function i(e,t,n,a,r,o,i){try{var l=e[o](i),s=l.value}catch(e){return void n(e)}l.done?t(s):Promise.resolve(s).then(a,r)}function l(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function h(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{},a=Object.keys(n);"function"==typeof Object.getOwnPropertySymbols&&(a=a.concat(Object.getOwnPropertySymbols(n).filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable})))),a.forEach((function(t){l(e,t,n[t])}))}return e}function u(e,t){return t=null!=t?t:{},Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):function(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n.push.apply(n,a)}return n}(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))})),e}class d extends a.DataSourceWithBackend{applyTemplateVariables(e,t){const n=(0,a.getTemplateSrv)();return u(h({},e),{database:e.database?n.replace(e.database,t):"",collection:e.collection?n.replace(e.collection,t):"",aggregation:e.aggregation?n.replace(e.aggregation,t,"json"):""})}query(e){return(0,a.getTemplateSrv)().updateTimeRange(e.range),super.query(e)}metricFindQuery(t,r){var o,l=this;return(o=function*(){const o={refId:"metricFindQuery",database:t.database,collection:t.collection,queryType:e.Table,timestampField:"",timestampFormat:"",labelFields:[],valueFields:[t.fieldName],valueFieldTypes:[t.fieldType],aggregation:t.aggregation,autoTimeBound:!1,autoTimeSort:!1,schemaInference:!1,schemaInferenceDepth:0};let i=u(h({},r),{targets:[o]});return(0,n.lastValueFrom)(l.query(i)).then((e=>{var t;if(e.error)throw new Error(e.error.message);return(null===(t=e.data)||void 0===t?void 0:t.length)?(0,a.frameToMetricFindValue)(e.data[0]):[]}))},function(){var e=this,t=arguments;return new Promise((function(n,a){var r=o.apply(e,t);function l(e){i(r,n,a,l,s,"next",e)}function s(e){i(r,n,a,l,s,"throw",e)}l(void 0)}))})()}constructor(e){super(e)}}var p=s(650),m=s.n(p),g=s(388);function y(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function b(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{},a=Object.keys(n);"function"==typeof Object.getOwnPropertySymbols&&(a=a.concat(Object.getOwnPropertySymbols(n).filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable})))),a.forEach((function(t){y(e,t,n[t])}))}return e}function f(e,t){return t=null!=t?t:{},Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):function(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n.push.apply(n,a)}return n}(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))})),e}class C extends p.PureComponent{renderCredentials(){const{options:e}=this.props,{secureJsonFields:t}=e,n=e.secureJsonData||{};return m().createElement(m().Fragment,null,m().createElement(g.InlineFieldRow,null,m().createElement(g.InlineField,{labelWidth:this.shortWidth,label:"Username"},m().createElement(g.SecretInput,{width:this.longWidth,isConfigured:t&&t.username,value:n.username||"",placeholder:"Username",onReset:this.onResetCredential,onChange:this.onUsernameChange})),m().createElement(g.InlineField,{label:"Password",labelWidth:this.shortWidth},m().createElement(g.SecretInput,{width:this.longWidth,isConfigured:t&&t.password,value:n.password||"",label:"Password",placeholder:"Password",onReset:this.onResetCredential,onChange:this.onPasswordChange}))))}renderTls(){const{options:e}=this.props,{jsonData:t}=e;return m().createElement(m().Fragment,null,m().createElement(g.Field,{label:"TLS Enabled"},m().createElement(g.Switch,{value:t.tls||!1,onChange:this.onTLSChange})),t.tls?this.renderTlsFields():null)}renderTlsFields(){const{options:e}=this.props,{jsonData:t}=e;return m().createElement(m().Fragment,null,m().createElement(g.Field,{label:"Insecure (Skip Verification)"},m().createElement(g.Switch,{value:t.tlsInsecure||!1,onChange:this.onTLSInsecureChange})),t.tlsInsecure?null:this.renderTlsVerification(),this.renderTlsClient())}renderTlsVerification(){const{options:e}=this.props,{jsonData:t}=e;return m().createElement(m().Fragment,null,m().createElement(g.Field,{label:"TLS Certificate Authority"},m().createElement(g.TextArea,{value:t.tlsCa||"",placeholder:`${this.beginCert}\n...\n${this.endCert}`,onChange:this.onTLSCAChange,cols:this.longWidth})),m().createElement(g.InlineField,{labelWidth:this.shortWidth,label:"Expected Server Name",tooltip:"If your server's certificates are for a different hostname than you use to connect, specify that different hostname here"},m().createElement(g.Input,{width:this.longWidth,name:"tlsServerName",type:"text",onChange:this.onTLSServerNameChange,value:t.tlsServerName||"",placeholder:"some.other.hostname"})))}renderTlsClient(){const{options:e}=this.props,{jsonData:t,secureJsonFields:n}=e,a=e.secureJsonData||{};return m().createElement(m().Fragment,null,m().createElement(g.Field,{label:"TLS Certificate"},m().createElement(g.TextArea,{value:t.tlsCertificate||"",placeholder:`${this.beginCert}\n...\n${this.endCert}`,onChange:this.onTLSCertificateChange,cols:this.longWidth})),m().createElement("br",null),m().createElement(g.Field,{label:"TLS Certificate Key"},m().createElement(g.SecretTextArea,{value:a.tlsCertificateKey||"",isConfigured:n&&n.tlsCertificateKey,placeholder:`${this.beginKey}\n...\n${this.endKey}`,onChange:this.onTLSCertificateKeyChange,onReset:this.onResetCredential,cols:this.longWidth})))}render(){const{options:e}=this.props,{jsonData:t}=e;return m().createElement(m().Fragment,null,m().createElement(g.FieldSet,{label:"MongoDB Connection",width:400},m().createElement(g.InlineField,{labelWidth:this.shortWidth,label:"URL"},m().createElement(g.Input,{width:this.longWidth,name:"url",type:"text",onChange:this.onURLChange,value:t.url||"",placeholder:"mongodb[+svc]://hostname:port[,hostname:port][/?key=value]"})),this.renderCredentials(),this.renderTls()))}constructor(...e){super(...e),y(this,"onURLChange",(e=>{const{onOptionsChange:t,options:n}=this.props,a=f(b({},n.jsonData),{url:e.target.value});t(f(b({},n),{jsonData:a}))})),y(this,"onTLSCAChange",(e=>{const{onOptionsChange:t,options:n}=this.props,a=f(b({},n.jsonData),{tlsCa:e.target.value});t(f(b({},n),{jsonData:a}))})),y(this,"onTLSCertificateChange",(e=>{const{onOptionsChange:t,options:n}=this.props,a=f(b({},n.jsonData),{tlsCertificate:e.target.value});t(f(b({},n),{jsonData:a}))})),y(this,"onTLSChange",(e=>{const{onOptionsChange:t,options:n}=this.props,a=f(b({},n.jsonData),{tls:e.target.checked});t(f(b({},n),{jsonData:a}))})),y(this,"onTLSServerNameChange",(e=>{const{onOptionsChange:t,options:n}=this.props,a=f(b({},n.jsonData),{tlsServerName:e.target.value});t(f(b({},n),{jsonData:a}))})),y(this,"onUsernameChange",(e=>{const{onOptionsChange:t,options:n}=this.props,a=f(b({},n.secureJsonData),{username:e.target.value});t(f(b({},n),{secureJsonData:a}))})),y(this,"onPasswordChange",(e=>{const{onOptionsChange:t,options:n}=this.props,a=f(b({},n.secureJsonData),{password:e.target.value});t(f(b({},n),{secureJsonData:a}))})),y(this,"onTLSInsecureChange",(e=>{const{onOptionsChange:t,options:n}=this.props,a=f(b({},n.jsonData),{tlsInsecure:e.target.checked});t(f(b({},n),{jsonData:a}))})),y(this,"onTLSCertificateKeyChange",(e=>{const{onOptionsChange:t,options:n}=this.props,a=f(b({},n.secureJsonData),{tlsCertificateKey:e.target.value});t(f(b({},n),{secureJsonData:a}))})),y(this,"onResetCredential",(()=>{const{onOptionsChange:e,options:t}=this.props;e(f(b({},t),{secureJsonFields:f(b({},t.secureJsonFields),{username:!1,password:!1,tlsCertificateKey:!1})}))})),y(this,"shortWidth",24),y(this,"longWidth",56),y(this,"beginCert","-----BEGIN CERTIFICATE-----"),y(this,"endCert","-----END CERTIFICATE-----"),y(this,"beginKey","-----BEGIN RSA PRIVATE KEY-----"),y(this,"endKey","-----END RSA PRIVATE KEY-----")}}var v=s(980);function F(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function T(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{},a=Object.keys(n);"function"==typeof Object.getOwnPropertySymbols&&(a=a.concat(Object.getOwnPropertySymbols(n).filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable})))),a.forEach((function(t){F(e,t,n[t])}))}return e}function O(e,t){return t=null!=t?t:{},Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):function(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n.push.apply(n,a)}return n}(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))})),e}class E extends p.PureComponent{render(){const t=(0,v.defaults)(this.props.query,r),{onChange:n,onRunQuery:a}=this.props;var o;return m().createElement(m().Fragment,null,m().createElement(g.FieldSet,null,m().createElement(g.InlineFieldRow,null,m().createElement(g.InlineField,{labelWidth:this.labelWidth,label:"Database.Collection"},m().createElement(g.Input,{width:this.longWidth,name:"database",type:"text",placeholder:"my_database",value:t.database||"",onChange:this.onDatabaseChange})),m().createElement(g.InlineField,{label:"."},m().createElement(g.Input,{width:this.longWidth,name:"collection",type:"text",placeholder:"my_collection",value:t.collection||"",onChange:this.onCollectionChange}))),m().createElement(g.InlineField,{labelWidth:this.labelWidth,tooltip:"Type of query to execute",label:"QueryType"},m().createElement(g.Select,{options:this.queryTypeOptions,value:null!==(o=this.queryTypeOptions.find((e=>e.value===t.queryType)))&&void 0!==o?o:this.queryTypeOptions[0],onChange:this.onQueryTypeChange(t,n,a),width:this.longWidth})),(t.queryType||this.defaultQueryType)===e.Timeseries&&m().createElement(m().Fragment,null,m().createElement(g.InlineField,{labelWidth:this.labelWidth,label:"Timestamp Field",tooltip:"Field to expect in every document containing the timestamp"},m().createElement(g.Input,{width:this.longWidth,value:t.timestampField||"",onChange:this.onTimestampFieldChange,type:"text",placeholder:"timestamp",name:"timestampField"})),m().createElement(g.InlineField,{labelWidth:this.labelWidth,label:"Timestamp Format",tooltip:"If blank, assume timestamps are native BSON dates. Otherwise, parse the timestamp as a string in the format described here: https://pkg.go.dev/time#Parse"},m().createElement(g.Input,{width:this.longWidth,value:t.timestampFormat||"",onChange:this.onTimestampFormatChange,type:"text",placeholder:"<BSON $date>",name:"timestampField"})),m().createElement(g.InlineFormLabel,{width:this.labelWidth,tooltip:"Each unique combination of these fields defines a separate time series. Nested fields are not supported, please project to a flat document"},"Label Fields"),m().createElement("div",null,t.labelFields.map(((e,t)=>m().createElement(g.InlineFieldRow,{key:t},m().createElement(g.Input,{width:this.longWidth,onChange:this.onLabelFieldChange(t),value:e,placeholder:"name"}),m().createElement(g.Button,{onClick:this.onLabelFieldRemove(t)},"-")))),m().createElement(g.Button,{onClick:this.onLabelFieldAppend},"+")),m().createElement(g.InlineField,{labelWidth:this.labelWidth,label:"Legend Format",tooltip:"Series name override. Replacements are:\n{{.Value}}: Value field name.\n{{.Labels.field_name}}: Value of the label with name 'field_name'\n{{.Labels}}: key=value,... for all labels\nSee https://pkg.go.dev/text/template for full syntax.\nFunctions from https://masterminds.github.io/sprig/ are provided"},m().createElement(g.Input,{value:t.legendFormat||"",onChange:this.onLegendFormatChange}))),(t.queryType||this.defaultQueryType)===e.Timeseries&&m().createElement(m().Fragment,null,m().createElement(g.InlineField,{label:"Automatic Time-Bound",labelWidth:this.labelWidth,tooltip:"Add a stage at the end of your pipeline to $match documents where Timestamp Field is within the current dashboard time range"},m().createElement(g.InlineSwitch,{value:t.autoTimeBound||!1,onChange:this.onAutoTimeBoundChange})),!!t.autoTimeBound&&m().createElement(g.InlineField,{label:"Time-Bound at Start",labelWidth:this.labelWidth,tooltip:"Instead add the automatic time bound $match stage at the beginning of your pipeline. This only works if your timestamp field is present and correctly formatted in your collection, but can improve performance by not processing records outside of the current time range"},m().createElement(g.InlineSwitch,{value:t.autoTimeBoundAtStart||!1,onChange:this.onAutoTimeBoundAtStartChange})),m().createElement(g.InlineField,{label:"Automatic Time-Sort",labelWidth:this.labelWidth,tooltip:"Add a stage at the end to $sort documents ascending by Timestamp Field"},m().createElement(g.InlineSwitch,{value:t.autoTimeSort||!1,onChange:this.onAutoTimeSortChange}))),m().createElement("div",{className:"gf-form"},m().createElement(g.InlineFormLabel,{width:this.labelWidth,tooltip:"If enabled, Grafana will attempt to figure out the types of your data based on the first few documents. Otherwise, you will need to specify the names and datatypes of each field"},"Infer Schema"),m().createElement(g.InlineSwitch,{value:t.schemaInference||!1,onChange:this.onSchemaInferenceChange})),t.schemaInference?m().createElement(m().Fragment,null,m().createElement(g.InlineField,{labelWidth:this.labelWidth,label:"Schema Inference Depth",tooltip:"How many documents to consider for inference before assuming no new fields will be present. If all documents have the same fields, you can set this to 1"},m().createElement(g.Input,{value:`${t.schemaInferenceDepth}`,onChange:this.onSchemaInferenceDepthChange,type:"number"}))):m().createElement(m().Fragment,null,m().createElement(g.InlineFormLabel,{width:this.labelWidth,tooltip:"These fields contain measurements or other recorded values. You must also specify the data types (float64, uint64, string, etc) for each field. Prefix with a star if a field may not appear in every document for a given series. See https://pkg.go.dev/github.com/grafana/grafana-plugin-sdk-go/data#FieldType for a list of valid types. Nested fields are not supported, please project to a flat document"},"Value Fields"),(0,v.zip)(t.valueFields,t.valueFieldTypes).map(((e,t)=>m().createElement(g.InlineFieldRow,{key:t},m().createElement(g.Input,{onChange:this.onValueFieldChange(t),width:this.longWidth,value:e[0],placeholder:"name"}),m().createElement(g.InlineField,{label:":"},m().createElement(g.Input,{onChange:this.onValueFieldTypeChange(t),width:this.longWidth,value:e[1],placeholder:"type"})),m().createElement(g.Button,{onClick:this.onValueFieldRemove(t)},"-")))),m().createElement(g.Button,{onClick:this.onValueFieldAppend},"+"))),m().createElement(g.InlineFormLabel,{width:this.labelWidth,tooltip:"Argument to db.collection.aggregate(...), a JSON array of pipeline stage objects. Helper functions like new Date() or ObjectId() are not supported, consult the MongoDB manual at https://www.mongodb.com/docs/manual/reference/mongodb-extended-json/ to see how to represent these functions in pure JSON"},"Aggregation"),m().createElement("div",{style:{resize:"vertical"}},m().createElement(g.CodeEditor,{height:"300px",showLineNumbers:!0,language:"json",value:t.aggregation||"",onBlur:this.onAggregationChange})))}constructor(...t){super(...t),F(this,"labelWidth",25),F(this,"longWidth",50),F(this,"queryTypeOptions",[{label:"Timeseries",value:e.Timeseries,description:"Return time-indexed series of values, distinguished by a set of labels"},{label:"Table",value:e.Table,description:"Return arbitrary rows for a table or further processing"}]),F(this,"defaultQueryType",e.Timeseries),F(this,"onDatabaseChange",(e=>{const{onChange:t,query:n}=this.props;t(O(T({},n),{database:e.target.value}))})),F(this,"onCollectionChange",(e=>{const{onChange:t,query:n,onRunQuery:a}=this.props;t(O(T({},n),{collection:e.target.value})),a()})),F(this,"onQueryTypeChange",((e,t,n)=>a=>{t(O(T({},e),{queryType:a.value})),n()})),F(this,"onTimestampFieldChange",(e=>{const{onChange:t,query:n,onRunQuery:a}=this.props;t(O(T({},n),{timestampField:e.target.value})),a()})),F(this,"onTimestampFormatChange",(e=>{const{onChange:t,query:n,onRunQuery:a}=this.props;t(O(T({},n),{timestampFormat:e.target.value})),a()})),F(this,"onLabelFieldChange",(e=>t=>{const{onChange:n,query:a,onRunQuery:r}=this.props;let o=Array.from(a.labelFields);o.splice(e,1,t.target.value),n(O(T({},a),{labelFields:o})),r()})),F(this,"onLabelFieldAppend",(()=>{const{onChange:e,query:t,onRunQuery:n}=this.props;let a=Array.from(t.labelFields);a.splice(t.labelFields.length,0,""),e(O(T({},t),{labelFields:a})),n()})),F(this,"onLabelFieldRemove",(e=>()=>{const{onChange:t,query:n,onRunQuery:a}=this.props;let r=Array.from(n.labelFields);r.splice(e,1),t(O(T({},n),{labelFields:r})),a()})),F(this,"onLegendFormatChange",(e=>{const{onChange:t,query:n,onRunQuery:a}=this.props;t(O(T({},n),{legendFormat:e.target.value})),a()})),F(this,"onSchemaInferenceChange",(e=>{const{onChange:t,query:n,onRunQuery:a}=this.props;t(O(T({},n),{schemaInference:e.target.checked})),a()})),F(this,"onSchemaInferenceDepthChange",(e=>{const{onChange:t,query:n,onRunQuery:a}=this.props;t(O(T({},n),{schemaInferenceDepth:parseInt(e.target.value,10)})),a()})),F(this,"onValueFieldChange",(e=>t=>{const{onChange:n,query:a,onRunQuery:r}=this.props;let o=Array.from(a.valueFields);o.splice(e,1,t.target.value),n(O(T({},a),{valueFields:o})),r()})),F(this,"onValueFieldTypeChange",(e=>t=>{const{onChange:n,query:a,onRunQuery:r}=this.props;let o=Array.from(a.valueFieldTypes);o.splice(e,1,t.target.value),n(O(T({},a),{valueFieldTypes:o})),r()})),F(this,"onValueFieldAppend",(()=>{const{onChange:e,query:t,onRunQuery:n}=this.props;let a=Array.from(t.valueFields),r=Array.from(t.valueFieldTypes);a.splice(t.valueFields.length,0,""),r.splice(t.valueFieldTypes.length,0,""),e(O(T({},t),{valueFields:a,valueFieldTypes:r})),n()})),F(this,"onValueFieldRemove",(e=>()=>{const{onChange:t,query:n,onRunQuery:a}=this.props;let r=Array.from(n.valueFields),o=Array.from(n.valueFieldTypes);r.splice(e,1),o.splice(e,1),t(O(T({},n),{valueFields:r,valueFieldTypes:o})),a()})),F(this,"onAutoTimeBoundChange",(e=>{const{onChange:t,query:n,onRunQuery:a}=this.props;t(O(T({},n),{autoTimeBound:e.currentTarget.checked})),a()})),F(this,"onAutoTimeBoundAtStartChange",(e=>{const{onChange:t,query:n,onRunQuery:a}=this.props;t(O(T({},n),{autoTimeBoundAtStart:e.currentTarget.checked})),a()})),F(this,"onAutoTimeSortChange",(e=>{const{onChange:t,query:n,onRunQuery:a}=this.props;t(O(T({},n),{autoTimeSort:e.currentTarget.checked})),a()})),F(this,"onAggregationChange",(e=>{const{onChange:t,query:n,onRunQuery:a}=this.props;t(O(T({},n),{aggregation:e})),a()}))}}function w(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function I(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{},a=Object.keys(n);"function"==typeof Object.getOwnPropertySymbols&&(a=a.concat(Object.getOwnPropertySymbols(n).filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable})))),a.forEach((function(t){w(e,t,n[t])}))}return e}function S(e,t){return t=null!=t?t:{},Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):function(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n.push.apply(n,a)}return n}(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))})),e}class j extends p.PureComponent{render(){const e=(0,v.defaults)(this.props.query,o);return m().createElement(m().Fragment,null,m().createElement(g.InlineFieldRow,null,m().createElement(g.InlineField,{labelWidth:this.labelWidth,label:"Database.Collection"},m().createElement(g.Input,{width:this.longWidth,name:"database",type:"text",placeholder:"my_database",onChange:this.onDatabaseChange,value:e.database})),m().createElement(g.InlineField,{label:"."},m().createElement(g.Input,{width:this.longWidth,name:"collection",type:"text",placeholder:"my_collection",onChange:this.onCollectionChange,value:e.collection}))),m().createElement(g.InlineFieldRow,null,m().createElement(g.InlineField,{label:"Field",labelWidth:this.labelWidth},m().createElement(g.Input,{width:this.longWidth,placeholder:"name",onChange:this.onFieldNameChange,value:e.fieldName})),m().createElement(g.InlineField,{label:":"},m().createElement(g.Input,{width:this.longWidth,placeholder:"type",onChange:this.onFieldTypeChange,value:e.fieldType}))),m().createElement(g.InlineFormLabel,{width:this.labelWidth,tooltip:"Argument to db.collection.aggregate(...), a JSON array of pipeline stage objects. Helper functions like new Date() or ObjectId() are not supported, consult the MongoDB manual at https://www.mongodb.com/docs/manual/reference/mongodb-extended-json/ to see how to represent these functions in pure JSON"},"Aggregation"),m().createElement(g.CodeEditor,{height:"200px",showLineNumbers:!0,language:"json",onBlur:this.onAggregationChange,value:e.aggregation}))}constructor(...e){super(...e),w(this,"labelWidth",25),w(this,"longWidth",50),w(this,"onDatabaseChange",(e=>{const{onChange:t,query:n}=this.props;t(S(I({},n),{database:e.target.value}))})),w(this,"onCollectionChange",(e=>{const{onChange:t,query:n}=this.props;t(S(I({},n),{collection:e.target.value}))})),w(this,"onFieldNameChange",(e=>{const{onChange:t,query:n}=this.props;t(S(I({},n),{fieldName:e.target.value}))})),w(this,"onFieldTypeChange",(e=>{const{onChange:t,query:n}=this.props;t(S(I({},n),{fieldType:e.target.value}))})),w(this,"onAggregationChange",(e=>{const{onChange:t,query:n}=this.props;t(S(I({},n),{aggregation:e}))}))}}const D=new t.DataSourcePlugin(d).setConfigEditor(C).setQueryEditor(E).setVariableQueryEditor(j)})(),c})()));
//# sourceMappingURL=module.js.map